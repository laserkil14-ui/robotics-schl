#include <chrono>
#include <functional>
#include <memory>
#include <vector>
#include <cmath>
#include <algorithm>

#include <rclcpp/rclcpp.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <sensor_msgs/msg/laser_scan.hpp>

using namespace std::chrono_literals;

class SelfDrive : public rclcpp::Node
{
  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
  int step_;

  // 주행 파라미터
  const float TARGET_SPEED = 0.15;
  const float SAFE_DISTANCE = 0.35;
  const float KP_ANGULAR = 1.5;

public:
  SelfDrive() : rclcpp::Node("self_drive"), step_(0)
  {
    auto qos = rclcpp::QoS(1).best_effort();

    scan_sub_ = this->create_subscription<sensor_msgs::msg::LaserScan>(
      "/scan", qos,
      std::bind(&SelfDrive::scan_callback, this, std::placeholders::_1));

    vel_pub_ = this->create_publisher<geometry_msgs::msg::Twist>("/cmd_vel", 1);
  }

  void scan_callback(const sensor_msgs::msg::LaserScan::SharedPtr scan)
  {
    float front = get_range_avg(scan, 0.0, 10.0);
    float left  = get_range_avg(scan, M_PI / 2.0, 20.0);
    float right = get_range_avg(scan, -M_PI / 2.0, 20.0);

    auto vel = decide_movement(front, left, right);

    RCLCPP_INFO(
      this->get_logger(),
      "Step %d | F %.2f L %.2f R %.2f | V %.2f W %.2f",
      step_, front, left, right, vel.linear.x, vel.angular.z);

    vel_pub_->publish(vel);
    step_++;
  }

private:
  // rad 기준 평균 거리 계산
  float get_range_avg(
    const sensor_msgs::msg::LaserScan::SharedPtr scan,
    double center_rad,
    double window_deg)
  {
    int count = 0;
    float sum = 0.0;

    double window_rad = window_deg * M_PI / 180.0;

    for (double a = center_rad - window_rad; a <= center_rad + window_rad;
         a += scan->angle_increment)
    {
      int idx = static_cast<int>((a - scan->angle_min) / scan->angle_increment);

      if (idx < 0 || idx >= static_cast<int>(scan->ranges.size()))
        continue;

      float r = scan->ranges[idx];

      if (!std::isnan(r) && !std::isinf(r) && r > 0.05)
      {
        sum += r;
        count++;
      }
    }

    if (count == 0)
      return 2.0;

    return sum / count;
  }

  geometry_msgs::msg::Twist decide_movement(float front, float left, float right)
  {
    geometry_msgs::msg::Twist vel;

    if (front < SAFE_DISTANCE)
    {
      vel.linear.x = 0.0;
      vel.angular.z = (left > right) ? 0.6 : -0.6;
    }
    else
    {
      vel.linear.x = TARGET_SPEED;

      float error = left - right;
      error = std::clamp(error, -1.0f, 1.0f);

      vel.angular.z = KP_ANGULAR * error;
    }

    return vel;
  }
};

int main(int argc, char *argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<SelfDrive>());
  rclcpp::shutdown();
  return 0;
}

